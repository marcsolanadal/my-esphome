substitutions:
  device_name: "llum-ventilador-marc"
  friendly_name: "llum-ventilador-marc"
  output_name_1: "Output 1"
  output_name_2: "Output 2"
  input_name_1: "Input 1"
  input_name_2: "Input 2"

  # ESPHome API used by Home Assistant, etc
  # If you go to this page it generates one for you automatically!
  # https://esphome.io/components/api.html#configuration-variables
  api_key: "ZrR4uhf4T3wDCORwIByhaMleNJ/pAD8faKeRY+9c8Vc="

  ota_password: "9b7972985d848049ab7cae6a7c871c7e" # Password used to remotely flash firmware

# For PCB v0.1.9 with dual core ESP32
esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

esp32:
  board: esp32doit-devkit-v1
  framework:
    type: arduino

logger:

mqtt:
  broker: !secret mqtt_broker_ip
  username: !secret mqtt_broker_username
  password: !secret mqtt_broker_password
  client_id: ${device_name}
  on_message:
    topic: "llum/toggle"
    qos: 0
    then:
      - switch.toggle: relay_1

# If you enable MQTT and you do not use the “native API” for Home Assistant, you must remove 
# the api: line from your ESPHome configuration, otherwise the ESP will reboot every 15 minutes 
# because no client connected to the native API.

# Enable Home Assistant API
# api:
#   encryption:
#     key: ${api_key}

ota:
  - platform: esphome
    password: ${ota_password}

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Optional manual IP
  manual_ip:
    static_ip: 10.0.20.31 # TODO: I don't like to have the IP specified in the device
    gateway: 10.0.20.1
    subnet: 255.255.255.0

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: ${device_name}
    password: !secret ap_password

captive_portal:

web_server:
  port: 80
  version: 3
  include_internal: true
  auth:
    username: !secret web_server_user
    password: !secret web_server_password
  local: true

i2c:
  sda: GPIO26
  scl: GPIO25

output:
  - platform: gpio
    id: "relay_output_1"
    pin: GPIO12
  - platform: gpio
    id: "relay_output_2"
    pin: GPIO13

switch:
  - platform: output
    id: "relay_1"
    name: "${output_name_1}"
    output: "relay_output_1"
  - platform: output
    id: "relay_2"
    name: "${output_name_2}"
    output: "relay_output_2"

# Restart Button
button:
  - platform: restart
    id: "restart_device"
    name: "${device_name} Restart"
    entity_category: 'diagnostic'

binary_sensor:
  
  # Button on device
  - platform: gpio
    name: "${devicename} Button"
    pin:
      number: GPIO4
      inverted: yes
      mode:
        input: true
        pullup: true
    on_press:
      then:
        - button.press: "restart_device"
    filters:
      - delayed_on_off: 5ms
    internal: true

  # Input 1
  - platform: gpio
    name: "${input_name_1}"
    id: "input_1"
    pin: GPIO5
    filters:
      - delayed_on_off: 50ms
    on_multi_click:

      # Single click (short press) - toggle relay_1
      - timing:
          - ON for at most 1s
        then:
          - logger.log: "${devicename} Button - TAP"
          - switch.toggle: relay_1
          - mqtt.publish:
              topic: "llum/info"
              payload: "Something happened!"

      # Hold (long press) - turn on relay_2, then off after 30 seconds
      - timing:
          - ON for at least 1s
        then:
          - logger.log: "${devicename} Button - HOLD"
          - switch.toggle: relay_2
          - if:
              condition:
                switch.is_on: relay_2
              then:
                - delay: 20min
                - switch.turn_off: relay_2
    internal: true
  
  # Input 2
  - platform: gpio
    id: "input_2"
    name: "${input_name_2}"
    pin: GPIO18
    filters:
      - delayed_on_off: 50ms
    on_press:
      then:
        - switch.toggle: relay_2
    internal: true

sensor:
  # Power Sensor
  - platform: ade7953_i2c
    irq_pin: GPIO27
    voltage:
      name: "${devicename} Voltage"
      entity_category: 'diagnostic'
    current_a:
      name: "${output_name_2} Current"
      entity_category: 'diagnostic'
    active_power_a:
      name: "${output_name_2} Power"
      id: power_channel_2
      entity_category: 'diagnostic'
      filters:
        - multiply: -1
    current_b:
      name: "${output_name_1} Current"
      entity_category: 'diagnostic'
    active_power_b:
      name: "${output_name_1} Power"
      id: power_channel_1
      entity_category: 'diagnostic'
    update_interval: 10s

  # Internal NTC Temperature sensor
  - platform: ntc
    sensor: temp_resistance_reading
    name: "${devicename} Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    icon: "mdi:thermometer"
    entity_category: 'diagnostic'
    calibration:
      b_constant: 3350
      reference_resistance: 4.7kOhm
      reference_temperature: 298.15K

  # Required for NTC sensor
  - platform: resistance
    id: temp_resistance_reading
    sensor: temp_analog_reading
    configuration: DOWNSTREAM
    resistor: 5.6kOhm

  # Required for NTC sensor
  - platform: adc
    id: temp_analog_reading
    pin: GPIO35
    attenuation: 12db
    update_interval: 10s
    
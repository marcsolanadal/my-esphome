substitutions:
  device_name: "persiana-dormitori"
  device_id: "persiana_dormitori"
  friendly_name: "Persiana Dormitori"
  topic_prefix: "persiana_dormitori"

packages:
  # Hardware configuration
  hardware: !include
    file: ../hardware/shelly-25.yaml
    vars:
      device_name: ${device_name}
      friendly_name: ${friendly_name}

  # Common functionality
  wifi: !include
    file: ../common/wifi.yaml
    vars:
      device_name: ${device_name}

  mqtt: !include
    file: ../common/mqtt.yaml
    vars:
      device_name: ${device_name}

  logger: !include ../common/logger.yaml
  web-server: !include ../common/web-server.yaml
  reset: !include ../common/reset.yaml
  time: !include ../common/time.yaml

# Device-specific WiFi configuration
wifi:
  # ssid: !secret wifi_ssid

  power_save_mode: HIGH # for ESP8266 LOW/HIGH are mixed up, https://github.com/esphome/issues/issues/1532i

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  # ap:
  #   ssid: ${device_name}
  #   password: !secret ap_password
  #
  # reboot_timeout: 0s

  # on_connect:
  #   - lambda: |-
  #       ESP_LOGD("debug", "----------------- Connected to WiFi!");
  # on_disconnect:
  #   - lambda: |-
  #       ESP_LOGD("debug", "----------------- Disconnected from WiFi!");
#
# captive_portal:
#
# ota:
#   - platform: esphome
#     id: my_ota
#     password: !secret ota_password
#

# Device-specific sensor logic
sensor:
  # Temperature safety monitoring
  - platform: template
    name: "Blind Temperature Monitor"
    lambda: |-
      // Reference the NTC temperature sensor from hardware package
      if (id(ntc_temperature).has_state()) {
        return id(ntc_temperature).state;
      }
      return NAN;
    unit_of_measurement: "Â°C"
    accuracy_decimals: 1
    update_interval: 30s
    on_value_range:
      above: 90
      then: # Security shutdown by overheating
        - switch.turn_on: _shutdown

# Device-specific input logic (maintained contact switch handling)
binary_sensor:
  - platform: template
    name: "Open Switch"
    id: open_switch
    lambda: |-
      return id(input_a).state;
    on_state:
      - if:
          condition:
            binary_sensor.is_on: open_switch
          then:
            - cover.open: blind
          else:
            - cover.stop: blind

  - platform: template
    name: "Close Switch"
    id: close_switch
    lambda: |-
      return id(input_b).state;
    on_state:
      - if:
          condition:
            binary_sensor.is_on: close_switch
          then:
            - cover.close: blind
          else:
            - cover.stop: blind

# Blind control logic - device-specific behavior
cover:
  - platform: current_based
    name: "Blind"
    id: blind

    # Use current sensors from hardware package
    open_sensor: open_current
    open_moving_current_threshold: 0.5
    open_duration: 12s
    open_action:
      - switch.turn_on: relay_a  # Hardware package relay ID

    close_sensor: close_current
    close_moving_current_threshold: 0.5
    close_duration: 10s
    close_action:
      - switch.turn_on: relay_b  # Hardware package relay ID

    stop_action:
      - switch.turn_off: relay_a  # Hardware package relay ID
      - switch.turn_off: relay_b  # Hardware package relay ID

    # Device-specific behavior parameters
    obstacle_rollback: 30%
    start_sensing_delay: 0.8s
    malfunction_detection: true
    malfunction_action:
      then:
        - logger.log: "Malfunction detected. Relay welded."

substitutions:
  device_name: "persiana-marc-piscina"
  friendly_name: "persiana-marc-piscina"
  output_name_1: "Output 1"
  output_name_2: "Output 2"
  input_name_1: "Input 1"
  input_name_2: "Input 2"

  # ESPHome API used by Home Assistant, etc
  # If you go to this page it generates one for you automatically!
  # https://esphome.io/components/api.html#configuration-variables
  api_key: "Q82myZN0Zg6Nd52safzDAjTWqEdlZA2lmuzNeWWwbNU="

  ap_password: "2BVh52hK4zqT" # Fallback WiFi Access Point password
  ota_password: "1c9dd3e5be9bad45c6d821905e8f4714" # Password used to remotely flash firmware

# For PCB v0.1.9 with dual core ESP32
esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

esp32:
  board: esp32doit-devkit-v1
  framework:
    type: arduino

# Enable logging
logger:

mqtt:
  broker: !secret mqtt_broker_ip
  username: !secret mqtt_broker_username
  password: !secret mqtt_broker_password

# If you enable MQTT and you do not use the “native API” for Home Assistant, you must remove 
# the api: line from your ESPHome configuration, otherwise the ESP will reboot every 15 minutes 
# because no client connected to the native API.

# Enable Home Assistant API
# api:
#   encryption:
#     key: ${api_key}

ota:
  - platform: esphome
    password: ${ota_password}

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Optional manual IP
  manual_ip:
    static_ip: 10.0.20.24 # TODO: I don't like to have the IP specified in the device
    gateway: 10.0.20.1
    subnet: 255.255.255.0

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: ${device_name}
    password: ${ap_password}

captive_portal:

web_server:
  port: 80
  version: 3
  include_internal: true
  auth:
    username: !secret web_server_user
    password: !secret web_server_password
  local: true

i2c:
  sda: GPIO26
  scl: GPIO25

# Internal Shelly Switch Outputs
switch:
  - platform: gpio
    id: "relay_1"
    name: "${output_name_1}"
    pin: GPIO13
    internal: true
    restore_mode: ALWAYS_OFF
    interlock: [relay_2]
    interlock_wait_time: 200ms
    
  - platform: gpio
    id: "relay_2"
    name: "${output_name_2}"
    pin: GPIO12
    internal: true
    restore_mode: ALWAYS_OFF
    interlock: [relay_1]
    interlock_wait_time: 200ms

button:
  - platform: restart
    id: "restart_device"
    name: "${device_name} Restart"
    entity_category: 'diagnostic'

# Define the global variable to track the current state
globals:
  - id: input_1_state
    type: int
    restore_value: yes
    initial_value: '0'

binary_sensor:
  
  # Button on device
  - platform: gpio
    name: "${devicename} Button"
    pin:
      number: GPIO4
      inverted: yes
      mode:
        input: true
        pullup: true
    on_press:
      then:
        - button.press: "restart_device"
    filters:
      - delayed_on_off: 5ms
    internal: true


  # Input 1 with custom toggle sequence using a switch statement and direct relay control
  - platform: gpio
    name: "${input_name_1}"
    id: "input_1"
    pin: GPIO5
    filters:
      - delayed_on_off: 50ms
    on_press:
      then:
        - lambda: |-
            switch (id(input_1_state)) {
              case 0:  // State: Relay 1 ON (up)
                id(relay_1).turn_on();
                id(input_1_state) = 1;
                break;

              case 1:  // State: Relay 1 OFF
                id(relay_1).turn_off();
                id(input_1_state) = 2;
                break;

              case 2:  // State: Relay 2 ON (down)
                id(relay_2).turn_on();
                id(input_1_state) = 3;
                break;

              case 3:  // State: Relay 2 OFF
                id(relay_2).turn_off();
                id(input_1_state) = 0;
                break;
            }
    internal: true
  
  # Input 2
  - platform: gpio
    id: "input_2"
    name: "${input_name_2}"
    pin: GPIO18
    filters:
      - delayed_on_off: 50ms
    on_press:
      then:
        - switch.toggle: relay_2
    internal: true

sensor:
  # Power Sensor
  - platform: ade7953_i2c
    irq_pin: GPIO27
    voltage:
      name: "${devicename} Voltage"
      entity_category: 'diagnostic'
    current_a:
      name: "${output_name_2} Current"
      entity_category: 'diagnostic'
    active_power_a:
      name: "${output_name_2} Power"
      id: power_channel_2
      entity_category: 'diagnostic'
      filters:
        - multiply: -1
    current_b:
      name: "${output_name_1} Current"
      entity_category: 'diagnostic'
    active_power_b:
      name: "${output_name_1} Power"
      id: power_channel_1
      entity_category: 'diagnostic'
    update_interval: 10s

  # Internal NTC Temperature sensor
  - platform: ntc
    sensor: temp_resistance_reading
    name: "${devicename} Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    icon: "mdi:thermometer"
    entity_category: 'diagnostic'
    calibration:
      b_constant: 3350
      reference_resistance: 4.7kOhm
      reference_temperature: 298.15K

  # Required for NTC sensor
  - platform: resistance
    id: temp_resistance_reading
    sensor: temp_analog_reading
    configuration: DOWNSTREAM
    resistor: 5.6kOhm

  # Required for NTC sensor
  - platform: adc
    id: temp_analog_reading
    pin: GPIO35
    attenuation: 12db
    update_interval: 10s
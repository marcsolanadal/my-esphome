globals:
  
  - id: shutter_open_time
    type: std::string
    restore_value: yes
    initial_value: '"08:30"'  # Default open time
  
  - id: shutter_close_time
    type: std::string
    restore_value: yes
    initial_value: '"19:00"'  # Default close time

  - id: shutter_opened_today
    type: bool
    restore_value: no
    initial_value: "false"

  - id: shutter_closed_today
    type: bool
    restore_value: no
    initial_value: "false"

  - id: input_1_state
    type: int
    restore_value: yes
    initial_value: '0'

  - id: movement_detected
    type: bool
    restore_value: no
    initial_value: "false"

  # Offsets for sunrise and sunset in minutes
  - id: sunrise_offset
    type: int
    restore_value: yes
    initial_value: '0'  # Default: No offset

  - id: sunset_offset
    type: int
    restore_value: yes
    initial_value: '0'  # Default: No offset

  - id: shutter_direction
    type: std::string
    restore_value: no
    initial_value: '"stopped"'  # Possible values: "up", "down", "stopped"

text_sensor:
  - platform: template
    name: "Shutter Movement Status"
    id: movement_status
    update_interval: 1s
    lambda: |-
      // Get current values from the built-in sensors and use absolute values
      float current_a = abs(id(power_channel_2).state);  // Channel A (down) current
      float current_b = abs(id(power_channel_1).state);  // Channel B (up) current

      if (current_a > 1.0) {
        id(shutter_direction) = "up";
        return std::string("Moving Up");
      } else if (current_b > 1.0) {
        id(shutter_direction) = "down";
        return std::string("Moving Down"); 
      } else {
        if (id(shutter_direction) == "up") {
          id(relay_1).turn_off();
          id(input_1_state) = 2;
        } else if (id(shutter_direction) == "down") {
          id(relay_2).turn_off();
          id(input_1_state) = 0;
        }
        id(shutter_direction) = "stopped";
        return std::string("Stopped");
      }     

  - platform: template
    name: "Shutter Open Time"
    update_interval: 10s
    lambda: |-
      return id(shutter_open_time);

  - platform: template
    name: "Shutter Close Time"
    update_interval: 10s
    lambda: |-
      return id(shutter_close_time);
   
mqtt:
  on_message:

    - topic: "${topic_prefix}/open"
      qos: 0
      then:
        - switch.toggle: relay_1

    - topic: "${topic_prefix}/close"
      qos: 0
      then:
        - switch.toggle: relay_2

    # MQTT topic to set the open time
    - topic: "${topic_prefix}/set_open_time"
      qos: 0
      then:
        - lambda: |-
            id(shutter_open_time) = x.c_str(); 

    # MQTT topic to set the close time
    - topic: "${topic_prefix}/set_close_time"
      qos: 0
      then:
        - lambda: |-
            id(shutter_close_time) = x.c_str(); 

    # MQTT topic to return the stored open and close times
    - topic: "${topic_prefix}/info"
      qos: 0
      then:
        - mqtt.publish:
            topic: "shutter/status"
            payload: !lambda |-
              auto current_time = id(sntp_time).now();
              char buffer[6];
              sprintf(buffer, "%02d:%02d", current_time.hour, current_time.minute);
              std::string current_time_str = buffer;

              char payload[60];
              snprintf(payload, sizeof(payload), "Open Time: %s\nClose Time: %s\nCurrent Time: %s\n", 
                       id(shutter_open_time).c_str(), 
                       id(shutter_close_time).c_str(),
                       current_time_str.c_str());
              return payload;

# Automation to check the current time and trigger shutters open/close
interval:
  - interval: 1min
    then:
      - lambda: |-
          auto current_time = id(sntp_time).now();
          char buffer[6];
          sprintf(buffer, "%02d:%02d", current_time.hour, current_time.minute);
          std::string current_time_str = buffer;

          // Check if it's time to open the shutters
          if (current_time_str == id(shutter_open_time) && !id(shutter_opened_today)) {
            id(relay_1).turn_on();
            id(shutter_opened_today) = true;  
          }

          // Check if it's time to close the shutters
          if (current_time_str == id(shutter_close_time)) {
            id(relay_2).turn_on(); 
            id(shutter_closed_today) = true;
          }
      
       # Reset open/close flags at midnight for the next day
      - lambda: |-
          auto current_time = id(sntp_time).now();
          if (current_time.hour == 0 && current_time.minute == 0) {
            id(shutter_opened_today) = false;
            id(shutter_closed_today) = false;
          }


# Internal Shelly Switch Outputs
switch:
  - platform: gpio
    id: "relay_1"
    name: "${output_name_1}"
    pin: GPIO13
    internal: true
    restore_mode: ALWAYS_OFF
    interlock: [relay_2]
    interlock_wait_time: 150ms
    
  - platform: gpio
    id: "relay_2"
    name: "${output_name_2}"
    pin: GPIO12
    internal: true
    restore_mode: ALWAYS_OFF
    interlock: [relay_1]
    interlock_wait_time: 150ms

binary_sensor:
  
  # Input 1 with custom toggle sequence using a switch statement and direct relay control
  - platform: gpio
    name: "${input_name_1}"
    id: "input_1"
    pin: GPIO5
    filters:
      - delayed_on_off: 100ms
    on_press:
      then:
        - lambda: |-
            switch (id(input_1_state)) {
              case 0:  // State: Relay 1 ON (up)
                  id(relay_1).turn_on();
                  id(input_1_state) = 1;
                break;

              case 1:  // State: Relay 1 OFF
                  id(relay_1).turn_off();
                  id(input_1_state) = 2;
                break;

              case 2:  // State: Relay 2 ON (down)
                  id(relay_2).turn_on();
                  id(input_1_state) = 3;
                break;

              case 3:  // State: Relay 2 OFF
                  id(relay_2).turn_off();
                  id(input_1_state) = 0;
                break;
              
              default:
                // Handle unexpected state
                id(input_1_state) = 0;  // Reset to initial state
                break;
            }
    internal: true
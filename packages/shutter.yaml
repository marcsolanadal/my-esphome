globals:
  
  - id: shutter_open_time
    type: std::string
    restore_value: yes
    initial_value: '"07:00"'  # Default open time
  
  - id: shutter_close_time
    type: std::string
    restore_value: yes
    initial_value: '"19:00"'  # Default close time

  - id: shutter_opened_today
    type: bool
    restore_value: no
    initial_value: "false"

  - id: shutter_closed_today
    type: bool
    restore_value: no
    initial_value: "false"

text_sensor:

  - platform: template
    name: "Shutter Open Time"
    update_interval: 10s
    lambda: |-
      return id(shutter_open_time);

  - platform: template
    name: "Shutter Close Time"
    update_interval: 10s
    lambda: |-
      return id(shutter_close_time);
   
mqtt:
  on_message:

    - topic: "shutter/open"
      qos: 0
      then:
        - switch.toggle: relay_1

    - topic: "shutter/close"
      qos: 0
      then:
        - switch.toggle: relay_2

    # MQTT topic to set the open time
    - topic: "shutter/set_open_time"
      qos: 0
      then:
        - lambda: |-
            id(shutter_open_time) = x.c_str(); 

    # MQTT topic to set the close time
    - topic: "shutter/set_close_time"
      qos: 0
      then:
        - lambda: |-
            id(shutter_close_time) = x.c_str(); 

    # MQTT topic to return the stored open and close times
    - topic: "shutter/info"
      qos: 0
      then:
        - mqtt.publish:
            topic: "shutter/status"
            payload: !lambda |-
              auto current_time = id(sntp_time).now();
              char buffer[6];
              sprintf(buffer, "%02d:%02d", current_time.hour, current_time.minute);
              std::string current_time_str = buffer;

              char payload[60];
              snprintf(payload, sizeof(payload), "Open Time: %s\nClose Time: %s\nCurrent Time: %s\n", 
                       id(shutter_open_time).c_str(), 
                       id(shutter_close_time).c_str(),
                       current_time_str.c_str());
              return payload;

# Automation to check the current time and trigger shutters open/close
interval:
  - interval: 1min
    then:
      - lambda: |-
          auto current_time = id(sntp_time).now();
          char buffer[6];
          sprintf(buffer, "%02d:%02d", current_time.hour, current_time.minute);
          std::string current_time_str = buffer;

          // Check if it's time to open the shutters
          if (current_time_str == id(shutter_open_time) && !id(shutter_opened_today)) {
            id(relay_1).turn_on();
            id(shutter_opened_today) = true;  
          }

          // Check if it's time to close the shutters
          if (current_time_str == id(shutter_close_time)) {
            id(relay_2).turn_on(); 
            id(shutter_closed_today) = true;
          }
      
       # Reset open/close flags at midnight for the next day
      - lambda: |-
          auto current_time = id(sntp_time).now();
          if (current_time.hour == 0 && current_time.minute == 0) {
            id(shutter_opened_today) = false;
            id(shutter_closed_today) = false;
          }

# Internal Shelly Switch Outputs
switch:
  - platform: gpio
    id: "relay_1"
    name: "${output_name_1}"
    pin: GPIO13
    internal: true
    restore_mode: ALWAYS_OFF
    interlock: [relay_2]
    interlock_wait_time: 200ms
    
  - platform: gpio
    id: "relay_2"
    name: "${output_name_2}"
    pin: GPIO12
    internal: true
    restore_mode: ALWAYS_OFF
    interlock: [relay_1]
    interlock_wait_time: 200ms

binary_sensor:
  
  # Input 1 with custom toggle sequence using a switch statement and direct relay control
  - platform: gpio
    name: "${input_name_1}"
    id: "input_1"
    pin: GPIO5
    filters:
      - delayed_on_off: 50ms
    on_press:
      then:
        - lambda: |-
            switch (id(input_1_state)) {
              case 0:  // State: Relay 1 ON (up)
                id(relay_1).turn_on();
                id(input_1_state) = 1;
                break;

              case 1:  // State: Relay 1 OFF
                id(relay_1).turn_off();
                id(input_1_state) = 2;
                break;

              case 2:  // State: Relay 2 ON (down)
                id(relay_2).turn_on();
                id(input_1_state) = 3;
                break;

              case 3:  // State: Relay 2 OFF
                id(relay_2).turn_off();
                id(input_1_state) = 0;
                break;
              
              default:
                // Handle unexpected state
                id(input_1_state) = 0;  // Reset to initial state
                break;
            }
    internal: true